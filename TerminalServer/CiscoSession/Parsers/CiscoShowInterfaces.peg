@namespace TerminalServer.CiscoSession.Parsers
@classname CiscoShowInterfaces
@using TerminalServer.CiscoSession.Model

ShowInterfaces<List<ShowInterfacesItem>>
 = CLICommand i:Interface*  { new List<ShowInterfacesItem>(i) }
 
CLICommand
 = 'show interfaces' WS? 
 
Interface<ShowInterfacesItem>
 = intId:InterfaceID 
   WS? 'is' WS?
   ls:LineStatus
   ps:ProtocolStatus?
   hw:HardwareIs?
   des:Description?
   addr:InternetAddressIs?
   met:Metrics?
   enc:Encapsulation?
   lo:LoopbackSetting?
   ka:Keepalive?
   ecp:EthernetCommunicationProperties?
   pcp:PPPCommunicationProperties?
   fc:FlowControl?
   pcm:PortChannelMembers?
   as:ARPStatistics?
   ti:Timers?
   qu:Queues?
   intStat:InterfaceStatistics? {
     new ShowInterfacesItem {
		InterfaceId = intId,
		LineStatus = ls,
		ProtocolStatus = ps.Count > 0 ? ps[0] : EInterfaceStatus.Unknown,
		Hardware = hw.Count > 0 ? hw[0] : null,
		Description = des.Count > 0 ? des[0] : "",
		IPv4Address = addr.Count > 0 ? addr[0] : null,
		Metrics = met.Count > 0 ? met[0] : null,
		Layer2Encapsulation = enc.Count > 0 ? enc[0] : ELayer2Encapsulation.Unknown,
		LoopbackSetting = lo.Count > 0 ? lo[0] : ELoopbackSetting.Unknown,
		Keepalive = ka.Count > 0 ? ka[0] : new InterfaceKeepaliveSettings { State = EInterfaceKeepalive.Unknown },
		ProtocolProperties = ecp.Count > 0 ? (Layer2ProtocolProperties) ecp[0] : (pcp.Count > 0 ? (Layer2ProtocolProperties) pcp[0] : null),
		PortChannelMembers = pcm.Count > 0 ? pcm[0] : null 
	 }
   }
 
InterfaceID<CiscoInterfaceId>
  	= a:InterfaceType b:InterfaceNumber c:ChannelNumber? d:SubinterfaceNumber? { ToCiscoInterfaceId(a, b, c, d) }

InterfaceType<EInterfaceType>
  = 'Vlan' { EInterfaceType.VLan }
  / 'Ethernet' { EInterfaceType.Ethernet }
  / 'FastEthernet' { EInterfaceType.FastEthernet }
  / 'GigabitEthernet' { EInterfaceType.GigabitEthernet }
  / 'TenGigabitEthernet' { EInterfaceType.TenGigabitEthernet }
  / 'Port-channel' { EInterfaceType.PortChannel }
  / 'Loopback' { EInterfaceType.Loopback }
  / 'Tunnel' { EInterfaceType.Tunnel }
  / 'Async' { EInterfaceType.Async }
  / 'NVI' { EInterfaceType.NVI }
  / 'ucse' { EInterfaceType.UCSE }
  / 'Embedded-Service-Engine' { EInterfaceType.EmbeddedServicesEngine }
  / 'BRI' { EInterfaceType.BasicRateInterface }
  / 'Null' { EInterfaceType.Null }

InterfaceNumber<CiscoInterfaceNumber>
	= a:Number '/' b:Number '/' c:Number '/' d:Number { new CiscoInterfaceNumber { Chassis=a, LineCard=b, Module=c, Port=d } }
	/ a:Number '/' b:Number '/' c:Number { new CiscoInterfaceNumber { LineCard=a, Module=b, Port=c } }
	/ a:Number '/' b:Number { new CiscoInterfaceNumber { Module=a, Port=b } }
	/ a:Number { new CiscoInterfaceNumber { Port=a } }
  	
SubinterfaceNumber<int>
  = '.' i:Number { i }

ChannelNumber<int>
  = ':' i:Number { i }
 
LineStatus<EInterfaceStatus>
  = i:InterfaceState Comma WS? { i }
  
ProtocolStatus<EInterfaceStatus>
  = 'line protocol is' WS? ps:InterfaceState WS? { ps }
  
InterfaceState<EInterfaceStatus>
  	= 'up' (WS? '(connected)')? { EInterfaceStatus.Up }
  	/ 'down' (WS? '(notconnect)')? { EInterfaceStatus.Down }
  	/ 'administratively down' { EInterfaceStatus.AdministrativelyDown }

HardwareIs<InterfaceHardware>
  = 'Hardware is' WS? ht:HardwareType WS? { ht }
  
HardwareType<InterfaceHardware>
  = 'Loopback' { new LoopbackInterfaceHardware() }
  / 'BRI with S/T interface and POTS' { new BasicRateInterfaceHardware() }
  / EthernetHardware
  
EthernetHardware<EthernetInterfaceHardware>
  = ct:EthernetChipType? 
    ht:EthernetHardwareType 
	Comma WS? 'address is' WS? 
	mac:MACAddress 
	WS? 
	bia:BurnedInEthernetMac? {
	  new EthernetInterfaceHardware {
	    MACAddress = mac,
		HardwareType = ht,
		BurnedInAddress = bia.Count > 0 ? bia[0] : null,
		ChipType = ct.Count > 0 ? ct[0] : EEthernetChipType.Unspecified
	  }
	}
 
EthernetChipType<EEthernetChipType>
  = 'PowerPC405' WS? { EEthernetChipType.PowerPC405 }
  / 'PQUICC' WS? { EEthernetChipType.PQUICC }
 
EthernetHardwareType<EInterfaceType>
  = 'EtherSVI' { EInterfaceType.VLan }
  / 'Ethernet' { EInterfaceType.Ethernet }
  / 'Fast' WS? 'Ethernet' { EInterfaceType.FastEthernet }
  / 'Gigabit Ethernet' { EInterfaceType.GigabitEthernet }
  / 'Ten Gigabit Ethernet' { EInterfaceType.TenGigabitEthernet }
  / 'EtherChannel' { EInterfaceType.PortChannel }

BurnedInEthernetMac<System.Net.NetworkInformation.PhysicalAddress>
 = '(bia' WS+ mac:MACAddress ')' { mac }

Description
  = 'Description:' WS? desc:[^\n\r]* WS? { string.Concat(desc) }
 
InternetAddressIs<NetworkPrefix>
  = 'Internet address is' WS? pref:Prefix { pref }
  
Prefix<NetworkPrefix>
 = na:IPAddress '/' len:Number WS? { new NetworkPrefix { NetworkAddress = na, Length = len } }

Metrics<InterfaceMetrics>
  = m:MTU
    bw:Bandwidth
    d:Delay
    r:Reliability
    tl:TransmitLoad
    rl:ReceiveLoad
	{
		new InterfaceMetrics {
			MTU = m,
			Bandwidth = bw,
			Delay = d,
			Reliability = r,
			TransmitLoad = tl,
			ReceiveLoad = rl
			}
	}
    
MTU<int>
  = 'MTU' WS? i:Number WS? 'bytes' Comma WS? { i }

Bandwidth<Int64>
  = 'BW' WS? x:BigNumber WS? u:DataRate Comma WS? { ExpandBandwidth(x, u) }
  
// TODO: Is timeunit ever anything but usec
Delay<int>
  = 'DLY' WS? i:Number WS? TimeUnit Comma WS? { i }
   
TimeUnit
  = 'usec' 
 
Reliability<Ratio>
  = 'reliability' WS? n:Number WS? '/' WS? d:Number Comma WS? { new Ratio { Numerator=n, Denominator=d } }
   
TransmitLoad<Ratio>
  = 'txload' WS? n:Number WS? '/' WS? d:Number WS? Comma WS? { new Ratio { Numerator=n, Denominator=d } }
 
ReceiveLoad<Ratio>
  = 'rxload' WS? n:Number WS? '/' WS? d:Number WS? { new Ratio { Numerator=n, Denominator=d } }

Encapsulation<ELayer2Encapsulation>
  = 'Encapsulation' WS? enc:EncapsulationType Comma WS? { enc } 

EncapsulationType<ELayer2Encapsulation>
  = 'ARPA' { ELayer2Encapsulation.ARPA }
  / 'LOOPBACK' { ELayer2Encapsulation.Loopback }
  / 'PPP' { ELayer2Encapsulation.PPP }
  
LoopbackSetting<ELoopbackSetting>
  = 'loopback' WS? lo:LoopbackIs WS? { lo }
  
LoopbackIs<ELoopbackSetting>
  = 'not set' { ELoopbackSetting.NotSet }

Keepalive<InterfaceKeepaliveSettings>
  = 'Keepalive' WS? ka:KeepaliveIs WS? { ka }
  
KeepaliveIs<InterfaceKeepaliveSettings>
  = 'not supported' { new InterfaceKeepaliveSettings { State = EInterfaceKeepalive.NotSupported } }
  / 'not set' { new InterfaceKeepaliveSettings { State = EInterfaceKeepalive.NotSet } }
  / 'set' WS? '(' s:Number WS? 'sec)' { new InterfaceKeepaliveSettings { State = EInterfaceKeepalive.Set, Interval=s } }
  
EthernetCommunicationProperties<EthernetProtocolProperties>
  = dup:EthernetDuplex Comma WS? 
    sp:EthernetSpeed Comma WS? 
	lt:EthernetLinkType WS? 
	mt:EthernetMediaType WS? {
	  new EthernetProtocolProperties
	  {
	    Duplex = dup,
		Speed = sp,
		LinkType = lt,
		MediaType = mt
	  }
	}
  
EthernetDuplex<EDuplex>
  = 'Half-duplex' { EDuplex.Half }
  / 'Full-duplex' { EDuplex.Full }
  / 'Auto-duplex' { EDuplex.Auto }
  / 'Unknown duplex' { EDuplex.Unknown }
  
EthernetSpeed<EthernetSpeed>
  = 'Unknown Speed' { new EthernetSpeed { Rate = EEthernetRateSetting.Unknown } }
  / 'Auto-speed' { new EthernetSpeed { Rate = EEthernetRateSetting.Auto } }
  / n:Number r:DataRate { new EthernetSpeed { Rate = EEthernetRateSetting.Unknown, Speed = ExpandBandwidth(n, r) } }
  
EthernetLinkType<EEthernetLinkType>
  = 'link type is' WS? lt:LinkTypes Comma? WS? { lt }
  
LinkTypes<EEthernetLinkType>
  = 'auto' { EEthernetLinkType.Auto }
  
EthernetMediaType<EEthernetMediaType>
  = 'MII' { EEthernetMediaType.MII }
  / 'media type is' WS? emt:EthernetPhysicalMediaType { emt }

EthernetPhysicalMediaType<EEthernetMediaType>
  = '10/100/1000BaseTX' { EEthernetMediaType.TenHundredGig }
  / 'Not Present' { EEthernetMediaType.NotPresent }
  / 'SFP-10GBase-CX1' { EEthernetMediaType.SFP10GBaseCX1 }
  / 'unknown' { EEthernetMediaType.Unknown }
   
PPPCommunicationProperties<PPPProtocolProperties>
  = lcp:LCP mls:Multilink? {
    new PPPProtocolProperties {
		LCPState = lcp,
		MultilinkState = mls.Count > 0 ? mls[0] : EMultilinkState.Unknown
	}
  }
  
LCP<ELinkControlProtocolState>
  = 'LCP' WS? ls:LCPState Comma? WS? { ls }
  
LCPState<ELinkControlProtocolState>
  = 'Closed' { ELinkControlProtocolState.Closed }
  
Multilink<EMultilinkState>
  = 'multilink' WS? ms:MultilinkState Comma? WS? { ms }
  
MultilinkState<EMultilinkState>
  = 'Closed' { EMultilinkState.Closed }
  
FlowControl
  = InputFlowControl OutputFlowControl
 
InputFlowControl
  = 'input flow-control is' WS? FlowControlType Comma? WS? 
 
OutputFlowControl
  = 'output flow-control is' WS? FlowControlType Comma? WS?
 
FlowControlType
  = 'off'
  / 'unsupported'
  
PortChannelMembers<List<CiscoInterfaceId>>
  = 'Members in this channel:' WS? i:InterfaceAbbreviations WS? { i }
  
InterfaceAbbreviations<List<CiscoInterfaceId>>
  = i:InterfaceAbbreviation* { new List<CiscoInterfaceId>(i) }
               
InterfaceAbbreviation<CiscoInterfaceId>
 = a:InterfacePrefix b:InterfaceNumber Comma? WS {
   new CiscoInterfaceId {
     InterfaceType = a,
	 InterfaceNumber = b
   }
 } 
 
InterfacePrefix<EInterfaceType>
 = 'Et' [h]? { EInterfaceType.Ethernet }
 / 'Fa' { EInterfaceType.FastEthernet }
 / 'Gi' { EInterfaceType.GigabitEthernet }
 / 'Te' { EInterfaceType.TenGigabitEthernet }
 
ARPStatistics
 = 'ARP type:' WS? ARPType Comma WS?
   'ARP Timeout' WS? TimeUgly WS

ARPType
  = 'ARPA'
 
Timers
 = LastInputTime
   LastOutputTime
   OutputHangTime
   LastCounterClearing
   
LastInputTime
 = 'Last input' WS? TimeUgly Comma? WS?

LastOutputTime
 = 'output' WS? TimeUgly Comma? WS?
   
OutputHangTime
 = 'output hang' WS? TimeUgly? WS?
 
LastCounterClearing
  = 'Last clearing of "show interface" counters' WS? TimeUgly? WS?
 
Queues
  = InputQueueCharacterisitics OutputQueueCharacterisitics
  
InputQueueCharacterisitics
  = InputQueue OutputDrops QueueingStrategy 
  
InputQueue
  = 'Input queue:' WS? Number '/' Number '/' Number '/' Number WS? '(size/max/drops/flushes);' WS?
    
OutputDrops
  = 'Total output drops:' WS? Number WS?
  
QueueingStrategy
  = 'Queueing strategy:' WS? QueueingStrategyType WS?
   
QueueingStrategyType
  = 'fifo'   
  / 'weighted fair'
  
OutputQueueCharacterisitics
   = OutputQueue
     Conversations?
     ReservedConversations?
     AvailableBandwidth?
     
OutputQueue
  = 'Output queue:' WS? Number '/' Number WS? '(size/max)' WS?
  / 'Output queue:' WS? Number '/' Number '/' Number '/' Number WS? '(size/max total/threshold/drops)' WS? 

Conversations
  = 'Conversations' WS? Number '/' Number '/' Number WS? '(active/max active/max total)' WS?

ReservedConversations
  = 'Reserved Conversations' WS? Number '/' Number WS? '(allocated/max allocated)' WS?

AvailableBandwidth
  = 'Available Bandwidth' WS? Number WS? DataRate WS?

InterfaceStatistics
  =  TransferRates InputStatistics OutputStatistics

TransferRates
  = InputRate OutputRate
  
InputRate
  = '5 minute input rate' WS? Number? WS? DataRate Comma WS? Number WS? PacketRate WS?

OutputRate
  = '5 minute output rate' WS? Number? WS? DataRate Comma WS? Number WS? PacketRate WS?
  
DataRate<Int64>
  = [Bb] 'it'? 's'? ('/s' 'ec'?)? { 1 }
  / [Kk] 'ilo'? [Bb] 'it'? 's'? ('/s' 'ec'?)? { 1000 }
  / [Mm] 'ega'? [Bb] 'it'? 's'? ('/s' 'ec'?)? { 1000000 }
  / [Gg] 'iga'? [Bb] 'it'? 's'? ('/s' 'ec'?)? { 1000000000 }

PacketRate
  = 'packets/sec'
    
InputStatistics
  = PacketsInput?
    BroadcastsInput?
    Runts?
    Giants?
    Throttles?
    InputErrors?
    InputCRC?
    InputFrame?
    InputOverrun?
    InputIgnored?
    InputAbort?
    WatchDog?
    InputMulticast?
    PauseInput?
    InputDribbleCondition?

PacketsInput
  = Number WS? 'packets input' Comma WS? BigNumber WS? 'bytes' (Comma WS? BigNumber WS? 'no buffer')? WS?

BroadcastsInput
  = 'Received' WS? BigNumber WS? 'broadcasts' WS? ('(' BigNumber WS? ('IP' WS)? 'multicasts)' WS?)? Comma? WS?

Runts
  = BigNumber WS? 'runts' Comma? WS?

Giants
  = BigNumber WS? 'giants' Comma? WS?

Throttles
  = BigNumber WS? 'throttles' Comma? WS?

InputErrors
  = BigNumber WS? 'input errors' Comma? WS?

InputCRC
  = BigNumber WS? 'CRC' Comma? WS?

InputFrame
  = BigNumber WS? 'frame' Comma? WS?

InputOverrun
  = BigNumber WS? 'overrun' Comma? WS?

InputIgnored
  = BigNumber WS? 'ignored' Comma? WS?

InputAbort
  = BigNumber WS? 'abort' Comma? WS?

WatchDog
  = BigNumber WS? 'watchdog' Comma? WS?

InputMulticast
  = BigNumber WS? 'multicast' Comma? WS?

PauseInput
  = BigNumber WS? 'pause input' Comma? WS?

InputDribbleCondition
  = BigNumber WS? 'input packets with dribble condition detected' WS?

OutputStatistics
  = PacketsOutput?
    Underruns?
    OutputErrors?
    Collisions?
    InterfaceResets?
    UnknownProtocolDrops?
    Babbles?
    LateCollisions?
    Deferred?
    LostCarrier?
    NoCarrier?
    PauseOutput?
    OutputBufferFailures?
    OutputBuffersSwappedOut?
    CarrierTransitions?

PacketsOutput
  = BigNumber WS? 'packets output' Comma WS? BigNumber WS? 'bytes' Comma? WS?
   
Underruns
  = BigNumber WS? 'underruns' Comma? WS?

OutputErrors
  = BigNumber WS? 'output errors' Comma? WS?
  
Collisions
  = BigNumber WS? 'collisions' Comma? WS?

InterfaceResets
  = BigNumber WS? 'interface resets' Comma? WS?
 
UnknownProtocolDrops
  = BigNumber WS? 'unknown protocol drops' Comma? WS?

Babbles
  = BigNumber WS? 'babbles' Comma? WS?

LateCollisions
  = BigNumber WS? 'late collision' Comma? WS?

Deferred
  = BigNumber WS? 'deferred' Comma? WS?

LostCarrier
  = BigNumber WS? 'lost carrier' Comma? WS?

NoCarrier
  = BigNumber WS? 'no carrier' Comma? WS?
  
PauseOutput
  = Number WS? 'pause output' Comma? WS?

OutputBufferFailures
  = BigNumber WS? 'output buffer failures' Comma? WS?

OutputBuffersSwappedOut
  = BigNumber WS? 'output buffers swapped out' Comma? WS?
  
CarrierTransitions
  = BigNumber WS? 'carrier transitions' Comma? WS?

///////// Common bits
  
IPAddress<System.Net.IPAddress>
 = i:(Octet '.' Octet '.' Octet '.' Octet) { System.Net.IPAddress.Parse(string.Concat(i)) }
 
Octet
 = '25' [0-5]
 / '2' [0-4][0-9]
 / [0-1][0-9][0-9]
 / [0-9][0-9]?

// TODO: Come up with a better name for this
TimeUgly<DateTime>
  = i:TimeUglyPart+ { CiscoTimeToDateTime(i) }
  / 'never' { new DateTime(0) }
  / TimeHMS 
  
TimeUglyPart<int>
  = n:Number u:[ywdhms] { CiscoTimeToSeconds(n, u) }
  
TimeHMS<DateTime>
  = h:Number ':' m:Number ':' s:Number { DateTime.Now.Subtract(new TimeSpan(h,m,s)) }
              
MACAddress<System.Net.NetworkInformation.PhysicalAddress>
  = i:(Hextet '.' Hextet '.' Hextet) { 
		ParseCiscoMACAddress(i) 
	}
  
Hextet
  = HexDigit HexDigit HexDigit HexDigit
 
HexDigit
  = [0-9A-Fa-f]
 
WS
  = [ \t\r\n]+

Number<int>
  = i:[0-9]+ { Convert.ToInt32(string.Concat(i)) }
 
BigNumber<Int64>
  = i:[0-9]+ { Convert.ToInt64(string.Concat(i)) }

CiscoPrompt
  = [A-Za-z][A-Za-z0-9-_]*[#>]

Comma
  = ','

EOF 
  = !.
